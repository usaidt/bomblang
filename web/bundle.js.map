{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAa;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,iBAAiB,GAAG,eAAe,GAAG,cAAc,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,eAAe;AACvS;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;ACrJF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,mBAAmB,GAAG,qBAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,0DAA0D,uDAAuD;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;AC3TN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb,gBAAgB,mBAAO,CAAC,+BAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,WAAW;AACzF;AACA;AACA;AACA,mDAAmD,cAAc,SAAS,UAAU,WAAW,YAAY;AAC3G,qDAAqD,eAAe,WAAW,6BAA6B;AAC5G;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK,YAAY,UAAU,WAAW,YAAY;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU,WAAW,YAAY;AAC5F;AACA;AACA,wBAAwB;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;AClPA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,gBAAgB,mBAAO,CAAC,+BAAS;AACjC,cAAc,mBAAO,CAAC,2BAAO;AAC7B;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB,UAAU,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,QAAQ,cAAc,UAAU,aAAa,WAAW,eAAe;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;AC3SD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAgB,iBAAiB,iBAAiB;;;;;;;UCrCnD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,oCAAc;AACtC,iBAAiB,mBAAO,CAAC,sCAAe;AACxC,sBAAsB,mBAAO,CAAC,gDAAoB;AAClD,gBAAgB,mBAAO,CAAC,oCAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D,cAAc,4CAA4C;AAC1D,cAAc,wCAAwC;AACtD,cAAc,gDAAgD;AAC9D,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D,cAAc,sDAAsD;AACpE,cAAc,wCAAwC;AACtD,cAAc,uDAAuD;AACrE,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D,cAAc,gDAAgD;AAC9D,cAAc,+CAA+C;AAC7D,cAAc,0CAA0C;AACxD,cAAc,+CAA+C;AAC7D,cAAc,gDAAgD;AAC9D,cAAc,wCAAwC;AACtD,cAAc,kDAAkD;AAChE,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,0CAA0C;AACxD,cAAc,+CAA+C;AAC7D,cAAc,gDAAgD;AAC9D,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D,cAAc,gDAAgD;AAC9D,cAAc,+CAA+C;AAC7D,cAAc,iDAAiD;AAC/D,cAAc,+CAA+C;AAC7D,cAAc,4CAA4C;AAC1D,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D,cAAc,4CAA4C;AAC1D,cAAc,wCAAwC;AACtD,cAAc,gDAAgD;AAC9D,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,2CAA2C;AACzD,cAAc,kDAAkD;AAChE,cAAc,0CAA0C;AACxD,cAAc,gDAAgD;AAC9D,cAAc,0CAA0C;AACxD,cAAc,gDAAgD;AAC9D,cAAc,gDAAgD;AAC9D,cAAc,8CAA8C;AAC5D,cAAc,gDAAgD;AAC9D,cAAc,+CAA+C;AAC7D,cAAc,0CAA0C;AACxD,cAAc,+CAA+C;AAC7D,cAAc,gDAAgD;AAC9D,cAAc,wCAAwC;AACtD,cAAc,qDAAqD;AACnE,cAAc,0CAA0C;AACxD,cAAc,iDAAiD;AAC/D,cAAc,0CAA0C;AACxD,cAAc,qDAAqD;AACnE,cAAc,gDAAgD;AAC9D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,IAAI,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D,iDAAiD,6BAA6B;AAC9E,yDAAyD,WAAW,QAAQ,aAAa;AACzF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qBAAqB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA,yDAAyD,KAAK,UAAU,MAAM,MAAM,MAAM,SAAS,SAAS;AAC5G;AACA,SAAS;AACT;AACA;AACA,wDAAwD,QAAQ,UAAU,QAAQ;AAClF;AACA,uCAAuC,aAAa,IAAI,YAAY;AACpE,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B,cAAc,cAAc;AACrG;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA,oDAAoD,EAAE,aAAa,0BAA0B,IAAI,2BAA2B,SAAS,eAAe,IAAI,gBAAgB;AACxK;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA,6DAA6D,cAAc,UAAU,MAAM,MAAM,MAAM,EAAE,aAAa;AACtH;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc,UAAU,MAAM,MAAM,MAAM,SAAS,SAAS;AACrH;AACA,SAAS;AACT;AACA;AACA,sDAAsD,QAAQ,UAAU,QAAQ;AAChF;AACA,uCAAuC,aAAa,IAAI,YAAY;AACpE,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://bomblang/./src/ast.ts","webpack://bomblang/./src/interpreter.ts","webpack://bomblang/./src/lexer.ts","webpack://bomblang/./src/parser.ts","webpack://bomblang/./src/token.ts","webpack://bomblang/webpack/bootstrap","webpack://bomblang/./web/app.ts"],"sourcesContent":["\"use strict\";\n// Abstract Syntax Tree definitions for bombLang\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Program = exports.BlockStmt = exports.TryStmt = exports.IfStmt = exports.AlertStmt = exports.ReturnStmt = exports.FunctionCallStmt = exports.FunctionDefStmt = exports.AssignmentStmt = exports.ChainExpr = exports.BinaryExpr = exports.IdentifierExpr = exports.LiteralExpr = exports.ASTNode = void 0;\nclass ASTNode {\n}\nexports.ASTNode = ASTNode;\n// Expressions\nclass LiteralExpr extends ASTNode {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    accept(visitor) {\n        return visitor.visitLiteralExpr(this);\n    }\n}\nexports.LiteralExpr = LiteralExpr;\nclass IdentifierExpr extends ASTNode {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    accept(visitor) {\n        return visitor.visitIdentifierExpr(this);\n    }\n}\nexports.IdentifierExpr = IdentifierExpr;\nclass BinaryExpr extends ASTNode {\n    constructor(left, operator, right) {\n        super();\n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n    }\n    accept(visitor) {\n        return visitor.visitBinaryExpr(this);\n    }\n}\nexports.BinaryExpr = BinaryExpr;\nclass ChainExpr extends ASTNode {\n    constructor(expressions) {\n        super();\n        this.expressions = expressions;\n    }\n    accept(visitor) {\n        return visitor.visitChainExpr(this);\n    }\n}\nexports.ChainExpr = ChainExpr;\n// Statements\nclass AssignmentStmt extends ASTNode {\n    constructor(expression, variable) {\n        super();\n        this.expression = expression;\n        this.variable = variable;\n    }\n    accept(visitor) {\n        return visitor.visitAssignmentStmt(this);\n    }\n}\nexports.AssignmentStmt = AssignmentStmt;\nclass FunctionDefStmt extends ASTNode {\n    constructor(name, params, body) {\n        super();\n        this.name = name;\n        this.params = params;\n        this.body = body;\n    }\n    accept(visitor) {\n        return visitor.visitFunctionDefStmt(this);\n    }\n}\nexports.FunctionDefStmt = FunctionDefStmt;\nclass FunctionCallStmt extends ASTNode {\n    constructor(name, args, resultVar) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.resultVar = resultVar;\n    }\n    accept(visitor) {\n        return visitor.visitFunctionCallStmt(this);\n    }\n}\nexports.FunctionCallStmt = FunctionCallStmt;\nclass ReturnStmt extends ASTNode {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    accept(visitor) {\n        return visitor.visitReturnStmt(this);\n    }\n}\nexports.ReturnStmt = ReturnStmt;\nclass AlertStmt extends ASTNode {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    accept(visitor) {\n        return visitor.visitAlertStmt(this);\n    }\n}\nexports.AlertStmt = AlertStmt;\nclass IfStmt extends ASTNode {\n    constructor(condition, thenBranch, elseBranch) {\n        super();\n        this.condition = condition;\n        this.thenBranch = thenBranch;\n        this.elseBranch = elseBranch;\n    }\n    accept(visitor) {\n        return visitor.visitIfStmt(this);\n    }\n}\nexports.IfStmt = IfStmt;\nclass TryStmt extends ASTNode {\n    constructor(label, tryBlock, catchBlock) {\n        super();\n        this.label = label;\n        this.tryBlock = tryBlock;\n        this.catchBlock = catchBlock;\n    }\n    accept(visitor) {\n        return visitor.visitTryStmt(this);\n    }\n}\nexports.TryStmt = TryStmt;\nclass BlockStmt extends ASTNode {\n    constructor(statements) {\n        super();\n        this.statements = statements;\n    }\n    accept(visitor) {\n        return visitor.visitBlockStmt(this);\n    }\n}\nexports.BlockStmt = BlockStmt;\nclass Program extends ASTNode {\n    constructor(statements) {\n        super();\n        this.statements = statements;\n    }\n    accept(visitor) {\n        return visitor.visitProgram(this);\n    }\n}\nexports.Program = Program;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Interpreter = exports.ReturnValue = exports.BombLangError = void 0;\nclass BombLangError extends Error {\n    constructor(message, label) {\n        super(message);\n        this.label = label;\n        this.name = 'BombLangError';\n    }\n}\nexports.BombLangError = BombLangError;\nclass ReturnValue extends Error {\n    constructor(value) {\n        super();\n        this.value = value;\n        this.name = 'ReturnValue';\n    }\n}\nexports.ReturnValue = ReturnValue;\nclass Interpreter {\n    constructor() {\n        this.globals = new Map();\n        this.locals = new Map();\n        this.functions = new Map();\n        this.callStack = [];\n        // Initialize built-in functions\n        this.setupBuiltins();\n    }\n    setupBuiltins() {\n        // Built-in functions are handled in visitFunctionCallStmt\n    }\n    interpret(program) {\n        try {\n            program.accept(this);\n        }\n        catch (error) {\n            if (error instanceof BombLangError) {\n                console.error(`💥 Explosion! ${error.message}`);\n            }\n            else if (error instanceof ReturnValue) {\n                // Return at global scope is ignored\n            }\n            else {\n                console.error(`💥 Unexpected explosion: ${error instanceof Error ? error.message : String(error)}`);\n            }\n        }\n    }\n    visitProgram(program) {\n        for (const stmt of program.statements) {\n            stmt.accept(this);\n        }\n    }\n    visitBlockStmt(stmt) {\n        for (const statement of stmt.statements) {\n            statement.accept(this);\n        }\n    }\n    visitAssignmentStmt(stmt) {\n        const value = stmt.expression.accept(this);\n        this.setVariable(stmt.variable, value);\n    }\n    visitFunctionDefStmt(stmt) {\n        this.functions.set(stmt.name, {\n            name: stmt.name,\n            params: stmt.params,\n            body: stmt.body\n        });\n    }\n    visitFunctionCallStmt(stmt) {\n        // Handle built-in functions\n        if (stmt.name === 'alert') {\n            throw new Error(\"Alert should be handled as AlertStmt\");\n        }\n        // Handle built-in explode command for testing error handling\n        if (stmt.name === 'explode') {\n            const label = stmt.args.length > 0 ? String(stmt.args[0].accept(this)) : undefined;\n            const message = stmt.args.length > 1 ? String(stmt.args[1].accept(this)) : \"Manual explosion!\";\n            throw new BombLangError(message, label);\n        }\n        // Handle user-defined functions\n        const func = this.functions.get(stmt.name);\n        if (!func) {\n            throw new BombLangError(`Unknown function: ${stmt.name}`);\n        }\n        // Evaluate arguments in the current scope BEFORE creating new frame\n        const argValues = stmt.args.map(arg => arg.accept(this));\n        // Create new scope for function\n        this.pushFrame();\n        let functionResult = 0;\n        try {\n            // Set up parameters using pre-evaluated values\n            argValues.forEach((argValue, index) => {\n                if (index < func.params.length) {\n                    this.setVariable(func.params[index], argValue);\n                }\n            });\n            // Execute function body\n            func.body.accept(this);\n            // If we get here without a return, return 0\n            functionResult = 0;\n        }\n        catch (error) {\n            if (error instanceof ReturnValue) {\n                functionResult = error.value;\n            }\n            else {\n                throw error;\n            }\n        }\n        finally {\n            // Pop frame first to get back to calling scope\n            this.popFrame();\n        }\n        // Now we're back in the calling scope, set the result variable if specified\n        if (stmt.resultVar) {\n            this.setVariable(stmt.resultVar, functionResult);\n        }\n        return functionResult;\n    }\n    visitReturnStmt(stmt) {\n        const value = stmt.value.accept(this);\n        throw new ReturnValue(value);\n    }\n    visitAlertStmt(stmt) {\n        const messages = stmt.args.map(arg => String(arg.accept(this)));\n        console.log(messages.join(' '));\n    }\n    visitIfStmt(stmt) {\n        const condition = stmt.condition.accept(this);\n        // In bombLang, conditions are expressions that should be evaluated\n        // For now, treat any non-zero value as true\n        if (this.isTruthy(condition)) {\n            stmt.thenBranch.accept(this);\n        }\n        else if (stmt.elseBranch) {\n            stmt.elseBranch.accept(this);\n        }\n    }\n    visitTryStmt(stmt) {\n        try {\n            stmt.tryBlock.accept(this);\n        }\n        catch (error) {\n            if (error instanceof BombLangError) {\n                // If the error has a label, only catch it if it matches\n                if (error.label) {\n                    if (error.label === stmt.label) {\n                        stmt.catchBlock.accept(this);\n                    }\n                    else {\n                        // Re-throw labeled errors with different labels\n                        throw error;\n                    }\n                }\n                else {\n                    // Catch unlabeled bombLang errors\n                    stmt.catchBlock.accept(this);\n                }\n            }\n            else if (error instanceof ReturnValue) {\n                // Don't catch return statements\n                throw error;\n            }\n            else {\n                // Catch any other runtime errors\n                stmt.catchBlock.accept(this);\n            }\n        }\n    }\n    visitLiteralExpr(expr) {\n        return expr.value;\n    }\n    visitIdentifierExpr(expr) {\n        return this.getVariable(expr.name);\n    }\n    visitBinaryExpr(expr) {\n        const left = expr.left.accept(this);\n        const right = expr.right.accept(this);\n        switch (expr.operator) {\n            case '+': return Number(left) + Number(right);\n            case '-': return Number(left) - Number(right);\n            case '*': return Number(left) * Number(right);\n            case '/':\n                if (Number(right) === 0) {\n                    throw new BombLangError(\"Division by zero!\");\n                }\n                return Math.floor(Number(left) / Number(right));\n            case '%': return Number(left) % Number(right);\n            case '==': return Number(left) === Number(right) ? 1 : 0;\n            case '!=': return Number(left) !== Number(right) ? 1 : 0;\n            case '>': return Number(left) > Number(right) ? 1 : 0;\n            case '>=': return Number(left) >= Number(right) ? 1 : 0;\n            case '<': return Number(left) < Number(right) ? 1 : 0;\n            case '<=': return Number(left) <= Number(right) ? 1 : 0;\n            default:\n                throw new BombLangError(`Unknown operator: ${expr.operator}`);\n        }\n    }\n    visitChainExpr(expr) {\n        if (expr.expressions.length === 0) {\n            return 0;\n        }\n        if (expr.expressions.length === 1) {\n            return expr.expressions[0].accept(this);\n        }\n        // Process chain: value op value op value...\n        let result = expr.expressions[0].accept(this);\n        for (let i = 1; i < expr.expressions.length; i += 2) {\n            if (i + 1 >= expr.expressions.length) {\n                throw new BombLangError(\"Incomplete chain expression - missing operand\");\n            }\n            const operator = expr.expressions[i].accept(this); // Should be operator literal\n            const rightValue = expr.expressions[i + 1].accept(this);\n            // Apply the operation\n            switch (String(operator)) {\n                case '+':\n                    result = Number(result) + Number(rightValue);\n                    break;\n                case '-':\n                    result = Number(result) - Number(rightValue);\n                    break;\n                case '*':\n                    result = Number(result) * Number(rightValue);\n                    break;\n                case '/':\n                    if (Number(rightValue) === 0) {\n                        throw new BombLangError(\"Division by zero explosion!\");\n                    }\n                    result = Math.floor(Number(result) / Number(rightValue));\n                    break;\n                case '%':\n                    result = Number(result) % Number(rightValue);\n                    break;\n                case '==':\n                    result = Number(result) === Number(rightValue) ? 1 : 0;\n                    break;\n                case '!=':\n                    result = Number(result) !== Number(rightValue) ? 1 : 0;\n                    break;\n                case '>':\n                    result = Number(result) > Number(rightValue) ? 1 : 0;\n                    break;\n                case '>=':\n                    result = Number(result) >= Number(rightValue) ? 1 : 0;\n                    break;\n                case '<':\n                    result = Number(result) < Number(rightValue) ? 1 : 0;\n                    break;\n                case '<=':\n                    result = Number(result) <= Number(rightValue) ? 1 : 0;\n                    break;\n                default:\n                    throw new BombLangError(`Unknown operator in chain: ${operator}`);\n            }\n        }\n        return result;\n    }\n    pushFrame() {\n        // Save current locals on the stack\n        this.callStack.push({\n            vars: new Map(this.locals)\n        });\n        // Clear locals for new function scope\n        this.locals = new Map();\n    }\n    popFrame() {\n        const frame = this.callStack.pop();\n        if (frame) {\n            // Restore previous local scope\n            this.locals = frame.vars;\n        }\n        else {\n            // No frame to restore, clear locals (back to global scope)\n            this.locals = new Map();\n        }\n    }\n    setVariable(name, value) {\n        // Always set variables in the current scope\n        // If we're in a function (callStack.length > 0), use locals\n        // Otherwise use globals\n        if (this.callStack.length > 0) {\n            this.locals.set(name, value);\n        }\n        else {\n            this.globals.set(name, value);\n        }\n    }\n    getVariable(name) {\n        // Check locals first (if we're in a function), then globals\n        if (this.callStack.length > 0 && this.locals.has(name)) {\n            return this.locals.get(name);\n        }\n        if (this.globals.has(name)) {\n            return this.globals.get(name);\n        }\n        throw new BombLangError(`Undefined variable: ${name}`);\n    }\n    isTruthy(value) {\n        if (typeof value === 'number') {\n            return value !== 0;\n        }\n        if (typeof value === 'string') {\n            return value.length > 0;\n        }\n        return Boolean(value);\n    }\n    // Debug method to see current state\n    getState() {\n        return {\n            globals: new Map(this.globals),\n            locals: new Map(this.locals),\n            functions: Array.from(this.functions.keys())\n        };\n    }\n}\nexports.Interpreter = Interpreter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lexer = void 0;\nconst token_1 = require(\"./token\");\nclass Lexer {\n    constructor(input) {\n        this.position = 0;\n        this.line = 1;\n        this.column = 1;\n        this.input = input;\n    }\n    tokenize() {\n        const tokens = [];\n        let token;\n        let tokenCount = 0;\n        do {\n            try {\n                token = this.nextToken();\n                if (token.type !== token_1.TokenType.Comment) {\n                    tokens.push(token);\n                }\n                tokenCount++;\n                // Safety check to prevent infinite loops\n                if (tokenCount > 1000) {\n                    throw new Error(`Tokenization aborted: too many tokens (${tokenCount}). Possible infinite loop.`);\n                }\n            }\n            catch (error) {\n                console.error(`Error at position ${this.position}, line ${this.line}, column ${this.column}:`);\n                console.error(`Current character: \"${this.current()}\" (code: ${this.current().charCodeAt(0)})`);\n                throw error;\n            }\n        } while (token.type !== token_1.TokenType.EOF);\n        return tokens;\n    }\n    nextToken() {\n        // Skip any whitespace characters silently\n        this.skipWhitespace();\n        if (this.isAtEnd()) {\n            return this.createToken(token_1.TokenType.EOF, \"\");\n        }\n        const char = this.current();\n        const token = this.scanToken(char);\n        if (token) {\n            return token;\n        }\n        throw new Error(`Unexpected character '${char}' at line ${this.line}, column ${this.column}`);\n    }\n    scanToken(char) {\n        switch (char) {\n            case '*': return this.createToken(token_1.TokenType.Asterisk, this.advance());\n            case '@': return this.createToken(token_1.TokenType.At, this.advance());\n            case '&': return this.createToken(token_1.TokenType.Ampersand, this.advance());\n            case '~': return this.createToken(token_1.TokenType.Tilde, this.advance());\n            case ':': return this.createToken(token_1.TokenType.Colon, this.advance());\n            case '^': return this.createToken(token_1.TokenType.Caret, this.advance());\n            case '_': return this.createToken(token_1.TokenType.Underscore, this.advance());\n            case '+': return this.createToken(token_1.TokenType.Plus, this.advance());\n            case '-': return this.createToken(token_1.TokenType.Dash, this.advance());\n            case '%': return this.createToken(token_1.TokenType.Percent, this.advance());\n            case '!':\n                // Look ahead for !=\n                if (this.peek() === '=') {\n                    this.advance(); // consume !\n                    this.advance(); // consume =\n                    return this.createToken(token_1.TokenType.BangEqual, '!=');\n                }\n                else {\n                    return this.createToken(token_1.TokenType.Bang, this.advance());\n                }\n            case '=':\n                // Look ahead for ==\n                if (this.peek() === '=') {\n                    this.advance(); // consume first =\n                    this.advance(); // consume second =\n                    return this.createToken(token_1.TokenType.EqualEqual, '==');\n                }\n                else {\n                    return null; // Single '=' is not a valid token\n                }\n            case '>':\n                // Look ahead for >=\n                if (this.peek() === '=') {\n                    this.advance(); // consume >\n                    this.advance(); // consume =\n                    return this.createToken(token_1.TokenType.GreaterEqual, '>=');\n                }\n                else {\n                    return this.createToken(token_1.TokenType.Greater, this.advance());\n                }\n            case '<':\n                // Look ahead for <=\n                if (this.peek() === '=') {\n                    this.advance(); // consume <\n                    this.advance(); // consume =\n                    return this.createToken(token_1.TokenType.LessEqual, '<=');\n                }\n                else {\n                    return this.createToken(token_1.TokenType.Less, this.advance());\n                }\n            case '/':\n                if (this.match('/')) {\n                    return this.comment();\n                }\n                return this.createToken(token_1.TokenType.Slash, this.advance());\n            case '\"':\n                return this.string();\n        }\n        if (this.isDigit(char)) {\n            return this.number();\n        }\n        if (this.isAlpha(char)) {\n            return this.identifier();\n        }\n        return null;\n    }\n    comment() {\n        const startColumn = this.column - 2; // Account for '//'\n        const startPosition = this.position - 2; // Start of '//'\n        while (!this.isAtEnd() && this.current() !== '\\n') {\n            this.advance();\n        }\n        return {\n            type: token_1.TokenType.Comment,\n            value: this.input.substring(startPosition, this.position),\n            line: this.line,\n            column: startColumn,\n        };\n    }\n    string() {\n        const startColumn = this.column;\n        this.advance(); // Consume opening \"\n        const start = this.position;\n        while (!this.isAtEnd() && this.current() !== '\"') {\n            if (this.current() === '\\n') {\n                this.line++;\n                this.column = 1;\n            }\n            this.advance();\n        }\n        if (this.isAtEnd()) {\n            throw new Error(`Unterminated string at line ${this.line}, column ${startColumn}`);\n        }\n        const value = this.input.substring(start, this.position);\n        this.advance(); // Consume closing \"\n        return { type: token_1.TokenType.String, value, line: this.line, column: startColumn };\n    }\n    number() {\n        const start = this.position;\n        this.advance(); // Consume the first digit\n        while (!this.isAtEnd() && this.isDigit(this.current())) {\n            this.advance();\n        }\n        const value = this.input.substring(start, this.position);\n        return this.createToken(token_1.TokenType.Number, value);\n    }\n    identifier() {\n        const start = this.position;\n        this.advance(); // Consume the first character\n        while (!this.isAtEnd() && this.isAlphaNumeric(this.current())) {\n            this.advance();\n        }\n        const value = this.input.substring(start, this.position);\n        const type = this.getKeyword(value) || token_1.TokenType.Identifier;\n        return this.createToken(type, value);\n    }\n    getKeyword(value) {\n        switch (value) {\n            case \"if\": return token_1.TokenType.If;\n            case \"else\": return token_1.TokenType.Else;\n            case \"return\": return token_1.TokenType.Return;\n            case \"alert\": return token_1.TokenType.Alert;\n            default: return null;\n        }\n    }\n    createToken(type, value) {\n        return { type, value, line: this.line, column: this.column - value.length };\n    }\n    advance() {\n        const char = this.input[this.position];\n        this.position++;\n        this.column++;\n        return char;\n    }\n    match(expected) {\n        // Check the next character, not the current one\n        if (this.position + 1 >= this.input.length)\n            return false;\n        if (this.input[this.position + 1] !== expected)\n            return false;\n        this.advance(); // Consume the next character\n        return true;\n    }\n    peek() {\n        if (this.position + 1 >= this.input.length)\n            return '\\0';\n        return this.input[this.position + 1];\n    }\n    current() {\n        if (this.isAtEnd())\n            return '\\0';\n        return this.input[this.position];\n    }\n    isAtEnd() {\n        return this.position >= this.input.length;\n    }\n    skipWhitespace() {\n        while (!this.isAtEnd()) {\n            const char = this.current();\n            switch (char) {\n                case ' ':\n                case '\\r':\n                case '\\t':\n                    this.advance();\n                    break;\n                case '\\n':\n                    this.line++;\n                    this.column = 1;\n                    this.advance();\n                    break;\n                default:\n                    return;\n            }\n        }\n    }\n    skipNewlines() {\n        while (this.peek() === '\\n' && !this.isAtEnd()) {\n            this.line++;\n            this.column = 1;\n            this.advance();\n        }\n    }\n    isDigit(char) {\n        return char >= '0' && char <= '9';\n    }\n    isAlpha(char) {\n        return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z');\n    }\n    isAlphaNumeric(char) {\n        return this.isAlpha(char) || this.isDigit(char);\n    }\n}\nexports.Lexer = Lexer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst token_1 = require(\"./token\");\nconst ast_1 = require(\"./ast\");\nclass Parser {\n    constructor(tokens) {\n        this.current = 0;\n        this.lastExpression = null; // Track last expression for conditionals\n        this.tokens = tokens;\n    }\n    parse() {\n        const statements = [];\n        while (!this.isAtEnd()) {\n            const stmt = this.statement();\n            if (stmt) {\n                statements.push(stmt);\n            }\n        }\n        return new ast_1.Program(statements);\n    }\n    statement() {\n        try {\n            // *expression @variable\n            if (this.match(token_1.TokenType.Asterisk)) {\n                return this.assignmentStatement();\n            }\n            // ~name-param1-param2_body_\n            if (this.match(token_1.TokenType.Tilde)) {\n                return this.functionDefinition();\n            }\n            // !function-args OR !alert-args OR !return-value\n            if (this.match(token_1.TokenType.Bang)) {\n                return this.functionCall();\n            }\n            // :if_body_:else_body_ (uses lastExpression as condition)\n            if (this.check(token_1.TokenType.Colon)) {\n                return this.ifStatement();\n            }\n            // ^label_try_^label_catch_\n            if (this.match(token_1.TokenType.Caret)) {\n                return this.tryStatement();\n            }\n            // Skip over unknown tokens\n            this.advance();\n            return null;\n        }\n        catch (error) {\n            // Skip to next statement on error\n            this.synchronize();\n            return null;\n        }\n    }\n    // *expression @variable\n    assignmentStatement() {\n        const expression = this.expression();\n        this.lastExpression = expression; // Store for potential conditional use\n        // Check if this is actually a conditional (expression followed by :if)\n        if (this.check(token_1.TokenType.Colon) && this.peekNext()?.type === token_1.TokenType.If) {\n            return this.ifStatement();\n        }\n        this.consume(token_1.TokenType.At, \"Expected '@' after expression in assignment\");\n        const varName = this.consume(token_1.TokenType.Identifier, \"Expected variable name after '@'\");\n        return new ast_1.AssignmentStmt(expression, varName.value);\n    }\n    // ~name-param1-param2_body_\n    functionDefinition() {\n        const name = this.consume(token_1.TokenType.Identifier, \"Expected function name after '~'\");\n        const params = [];\n        // Parse parameters: -param1-param2-param3\n        while (this.match(token_1.TokenType.Dash)) {\n            const param = this.consume(token_1.TokenType.Identifier, \"Expected parameter name after '-'\");\n            params.push(param.value);\n        }\n        this.consume(token_1.TokenType.Underscore, \"Expected '_' to start function body\");\n        const body = this.blockStatement();\n        return new ast_1.FunctionDefStmt(name.value, params, body);\n    }\n    // !name-args @result OR !alert-args OR !return-value\n    functionCall() {\n        if (this.check(token_1.TokenType.Alert)) {\n            this.advance(); // consume 'alert'\n            const args = this.parseAlertArguments();\n            return new ast_1.AlertStmt(args);\n        }\n        if (this.check(token_1.TokenType.Return)) {\n            this.advance(); // consume 'return'\n            const value = this.expression();\n            return new ast_1.ReturnStmt(value);\n        }\n        // Regular function call: !funcname-arg1-arg2@result OR !funcname arg1 arg2@result\n        if (this.check(token_1.TokenType.Identifier)) {\n            const name = this.advance().value;\n            const args = this.parseFunctionArguments();\n            let resultVar;\n            if (this.match(token_1.TokenType.At)) {\n                const varToken = this.consume(token_1.TokenType.Identifier, \"Expected variable name after '@'\");\n                resultVar = varToken.value;\n            }\n            return new ast_1.FunctionCallStmt(name, args, resultVar);\n        }\n        throw new Error(\"Expected function name after '!'\");\n    }\n    // Parse -arg1-arg2-\"string\"-arg3 etc.\n    parseArgumentList() {\n        const args = [];\n        while (this.match(token_1.TokenType.Dash)) {\n            args.push(this.primary());\n        }\n        return args;\n    }\n    // Parse arguments for alert statements (no dashes required)\n    parseAlertArguments() {\n        const args = [];\n        // Parse all following expressions until we hit a statement boundary\n        while (!this.isAtEnd() &&\n            !this.check(token_1.TokenType.Bang) &&\n            !this.check(token_1.TokenType.Asterisk) &&\n            !this.check(token_1.TokenType.Tilde) &&\n            !this.check(token_1.TokenType.Caret) &&\n            !this.check(token_1.TokenType.Colon) &&\n            !this.check(token_1.TokenType.Underscore)) {\n            args.push(this.primary());\n        }\n        return args;\n    }\n    // :if_body_:else_body_\n    ifStatement() {\n        this.consume(token_1.TokenType.Colon, \"Expected ':'\");\n        this.consume(token_1.TokenType.If, \"Expected 'if'\");\n        this.consume(token_1.TokenType.Underscore, \"Expected '_' after 'if'\");\n        const thenBranch = this.blockStatement();\n        let elseBranch;\n        if (this.check(token_1.TokenType.Colon) && this.peekNext()?.type === token_1.TokenType.Else) {\n            this.advance(); // consume ':'\n            this.advance(); // consume 'else'\n            this.consume(token_1.TokenType.Underscore, \"Expected '_' after 'else'\");\n            elseBranch = this.blockStatement();\n        }\n        // Use the last expression as the condition\n        const condition = this.lastExpression || new ast_1.LiteralExpr(1);\n        return new ast_1.IfStmt(condition, thenBranch, elseBranch);\n    }\n    // ^label_try_^label_catch_\n    tryStatement() {\n        const label = this.consume(token_1.TokenType.Identifier, \"Expected label after '^'\");\n        this.consume(token_1.TokenType.Underscore, \"Expected '_' after label\");\n        const tryBlock = this.blockStatement();\n        this.consume(token_1.TokenType.Caret, \"Expected '^' for catch block\");\n        this.consume(token_1.TokenType.Identifier, \"Expected same label for catch block\");\n        this.consume(token_1.TokenType.Underscore, \"Expected '_' after catch label\");\n        const catchBlock = this.blockStatement();\n        return new ast_1.TryStmt(label.value, tryBlock, catchBlock);\n    }\n    blockStatement() {\n        const statements = [];\n        while (!this.check(token_1.TokenType.Underscore) && !this.isAtEnd()) {\n            const stmt = this.statement();\n            if (stmt) {\n                statements.push(stmt);\n            }\n        }\n        this.consume(token_1.TokenType.Underscore, \"Expected '_' to close block\");\n        return new ast_1.BlockStmt(statements);\n    }\n    expression() {\n        return this.chainExpression();\n    }\n    // Handle chained expressions like *x&+&y&+&z& or *5&+&3&*&2&\n    chainExpression() {\n        let expr = this.primary();\n        const chain = [expr];\n        while (this.match(token_1.TokenType.Ampersand)) {\n            if (this.checkOperator()) {\n                const operator = this.advance().value;\n                chain.push(new ast_1.LiteralExpr(operator));\n                // Expect another ampersand and then a value\n                this.consume(token_1.TokenType.Ampersand, \"Expected '&' after operator in chain\");\n                chain.push(this.primary());\n            }\n            else {\n                throw new Error(\"Expected operator after '&'\");\n            }\n        }\n        if (chain.length > 1) {\n            return new ast_1.ChainExpr(chain);\n        }\n        return expr;\n    }\n    primary() {\n        if (this.match(token_1.TokenType.Number)) {\n            const value = this.previous().value;\n            return new ast_1.LiteralExpr(parseInt(value, 10));\n        }\n        if (this.match(token_1.TokenType.String)) {\n            const value = this.previous().value;\n            return new ast_1.LiteralExpr(value);\n        }\n        // Check for implicit value reference (no * prefix in chains)\n        if (this.match(token_1.TokenType.Identifier)) {\n            const value = this.previous().value;\n            return new ast_1.IdentifierExpr(value);\n        }\n        throw new Error(`Unexpected token: ${this.peek().type} at line ${this.peek().line}`);\n    }\n    checkOperator() {\n        return this.check(token_1.TokenType.Plus) ||\n            this.check(token_1.TokenType.Dash) ||\n            this.check(token_1.TokenType.Asterisk) ||\n            this.check(token_1.TokenType.Slash) ||\n            this.check(token_1.TokenType.Percent) ||\n            this.check(token_1.TokenType.EqualEqual) ||\n            this.check(token_1.TokenType.BangEqual) ||\n            this.check(token_1.TokenType.Greater) ||\n            this.check(token_1.TokenType.GreaterEqual) ||\n            this.check(token_1.TokenType.Less) ||\n            this.check(token_1.TokenType.LessEqual);\n    }\n    // Parse arguments for function calls (supports both -arg1-arg2 and arg1 arg2 styles)\n    parseFunctionArguments() {\n        const args = [];\n        // Check if we're using dash-separated style (-arg1-arg2)\n        if (this.check(token_1.TokenType.Dash)) {\n            while (this.match(token_1.TokenType.Dash)) {\n                args.push(this.primary());\n            }\n        }\n        else {\n            // Use space-separated style (arg1 arg2) - parse until @ or statement boundary\n            while (!this.isAtEnd() &&\n                !this.check(token_1.TokenType.At) &&\n                !this.check(token_1.TokenType.Bang) &&\n                !this.check(token_1.TokenType.Asterisk) &&\n                !this.check(token_1.TokenType.Tilde) &&\n                !this.check(token_1.TokenType.Caret) &&\n                !this.check(token_1.TokenType.Colon) &&\n                !this.check(token_1.TokenType.Underscore)) {\n                args.push(this.primary());\n            }\n        }\n        return args;\n    }\n    // Utility methods\n    match(...types) {\n        for (const type of types) {\n            if (this.check(type)) {\n                this.advance();\n                return true;\n            }\n        }\n        return false;\n    }\n    check(type) {\n        if (this.isAtEnd())\n            return false;\n        return this.peek().type === type;\n    }\n    advance() {\n        if (!this.isAtEnd())\n            this.current++;\n        return this.previous();\n    }\n    isAtEnd() {\n        return this.peek().type === token_1.TokenType.EOF;\n    }\n    peek() {\n        return this.tokens[this.current];\n    }\n    peekNext() {\n        if (this.current + 1 >= this.tokens.length)\n            return null;\n        return this.tokens[this.current + 1];\n    }\n    previous() {\n        return this.tokens[this.current - 1];\n    }\n    consume(type, message) {\n        if (this.check(type))\n            return this.advance();\n        const current = this.peek();\n        throw new Error(`${message}. Got ${current.type} at line ${current.line}, column ${current.column}`);\n    }\n    synchronize() {\n        this.advance();\n        while (!this.isAtEnd()) {\n            if (this.previous().type === token_1.TokenType.Underscore)\n                return;\n            switch (this.peek().type) {\n                case token_1.TokenType.Asterisk:\n                case token_1.TokenType.Tilde:\n                case token_1.TokenType.Bang:\n                case token_1.TokenType.Colon:\n                case token_1.TokenType.Caret:\n                    return;\n            }\n            this.advance();\n        }\n    }\n}\nexports.Parser = Parser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TokenType = void 0;\nvar TokenType;\n(function (TokenType) {\n    // Core symbols needed for bombLang\n    TokenType[\"Asterisk\"] = \"ASTERISK\";\n    TokenType[\"At\"] = \"AT\";\n    TokenType[\"Ampersand\"] = \"AMPERSAND\";\n    TokenType[\"Bang\"] = \"BANG\";\n    TokenType[\"Tilde\"] = \"TILDE\";\n    TokenType[\"Colon\"] = \"COLON\";\n    TokenType[\"Caret\"] = \"CARET\";\n    TokenType[\"Dash\"] = \"DASH\";\n    TokenType[\"Underscore\"] = \"UNDERSCORE\";\n    // Literals\n    TokenType[\"Number\"] = \"NUMBER\";\n    TokenType[\"String\"] = \"STRING\";\n    TokenType[\"Identifier\"] = \"IDENTIFIER\";\n    // Operators (used in chains)\n    TokenType[\"Plus\"] = \"PLUS\";\n    TokenType[\"Slash\"] = \"SLASH\";\n    TokenType[\"Percent\"] = \"PERCENT\";\n    TokenType[\"EqualEqual\"] = \"EQUAL_EQUAL\";\n    TokenType[\"BangEqual\"] = \"BANG_EQUAL\";\n    TokenType[\"Greater\"] = \"GREATER\";\n    TokenType[\"GreaterEqual\"] = \"GREATER_EQUAL\";\n    TokenType[\"Less\"] = \"LESS\";\n    TokenType[\"LessEqual\"] = \"LESS_EQUAL\";\n    // Keywords\n    TokenType[\"If\"] = \"IF\";\n    TokenType[\"Else\"] = \"ELSE\";\n    TokenType[\"Return\"] = \"RETURN\";\n    TokenType[\"Alert\"] = \"ALERT\";\n    // Misc\n    TokenType[\"Comment\"] = \"COMMENT\";\n    TokenType[\"EOF\"] = \"EOF\";\n})(TokenType || (exports.TokenType = TokenType = {}));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lexer_1 = require(\"../src/lexer\");\nconst parser_1 = require(\"../src/parser\");\nconst interpreter_1 = require(\"../src/interpreter\");\nconst token_1 = require(\"../src/token\");\n// Comprehensive example code snippets for the REPL\nconst examples = {\n    // Beginner Examples\n    simple: `// Simple variable assignment\n*5 @x\n*10 @y\n!alert \"Variables assigned!\"`,\n    strings: `// String literals and concatenation\n*\"Hello\" @greeting\n*\"World\" @target\n!alert greeting target`,\n    operators: `// Basic arithmetic operations\n*5 @x\n*3 @y\n*x & + & y @sum\n*x & * & y @product\n!alert \"Sum:\" sum \"Product:\" product`,\n    alerts: `// Alert messages\n!alert \"Welcome to BombLang!\"\n*42 @answer\n!alert \"The answer is\" answer`,\n    // Intermediate Examples\n    functions: `// Function definition and calling\n~double-n_*n & * & 2 @doubled !return doubled_\n\n*7 @num\n!double num @result\n!alert \"Double of\" num \"is\" result`,\n    conditionals: `// Conditional statements\n*15 @x\n*x & > & 10:if_\n  !alert \"x is greater than 10\"\n_:else_\n  !alert \"x is not greater than 10\"\n_`,\n    comparisons: `// Comparison operations\n*5 & != & 3 @result1\n*2 & <= & 7 @result2\n*9 & >= & 4 @result3\n!alert \"Results:\" result1 result2 result3`,\n    chained: `// Chained operations with functions\n~double-n_*n & * & 2 @doubled !return doubled_\n~quadruple-n_!double n @temp !double temp @quad !return quad_\n\n*7 @num\n!quadruple num @final\n!alert \"Quadruple of\" num \"is\" final`,\n    // Advanced Examples\n    recursion: `// Recursive factorial function\n~factorial-n_*n & <= & 1:if_!return 1_*n & - & 1 @prev !factorial prev @prevfact *n & * & prevfact @result !return result_\n\n*5 @input\n!factorial input @result\n!alert \"Factorial of\" input \"is\" result`,\n    fibonacci: `// Fibonacci with recursive approach\n~fibonacci-n_*n & <= & 1:if_!return n_*n & - & 1 @prev1 *n & - & 2 @prev2 !fibonacci prev1 @fib1 !fibonacci prev2 @fib2 *fib1 & + & fib2 @result !return result_\n\n*8 @num\n!fibonacci num @fib\n!alert \"Fibonacci of\" num \"is\" fib`,\n    errors: `// Error handling with try-catch\n~safeDivide-a-b_*b & == & 0:if_!explode \"divzero\" \"Cannot divide by zero!\"_*a & / & b @result !return result_\n\n*10 @numerator\n*0 @denominator\n\n^divzero_!safeDivide numerator denominator @result !alert \"Result:\" result_^divzero_!alert \"Division by zero caught!\"_`,\n    complex: `// Complex calculation with multiple features\n~isEven-num_*num & % & 2 & == & 0 @check !return check_\n~complexCalc-a-b_*a & * & b @step1 *step1 & + & 10 @step2 !isEven step2 @evenCheck !return step2_\n\n*12 @x\n*8 @y\n!complexCalc x y @result\n!alert \"Complex result:\" result`,\n    // Experimental Examples\n    nested: `// Nested function calls\n~add-a-b_*a & + & b @sum !return sum_\n~multiply-a-b_*a & * & b @product !return product_\n~addThenMultiply-a-b-c_!add a b @sum !multiply sum c @result !return result_\n\n*3 @x\n*4 @y\n*5 @z\n!addThenMultiply x y z @final\n!alert \"Result of (3+4)*5 =\" final`,\n    memoization: `// Fibonacci with step-by-step calculation\n~fibonacci-n_\n  !alert \"Calculating fibonacci of\" n\n  *n & <= & 1:if_\n    !alert \"Base case reached\"\n    !return n\n  _\n  *n & - & 1 @prev1\n  *n & - & 2 @prev2\n  !fibonacci prev1 @fib1\n  !fibonacci prev2 @fib2\n  *fib1 & + & fib2 @result\n  !return result\n_\n\n*5 @test\n!fibonacci test @result\n!alert \"Final result:\" result`,\n    validators: `// Input validation example\n~validateAge-age_\n  *age & < & 0:if_\n    !alert \"Age cannot be negative\"\n    !return 0\n  _\n  *age & > & 150:if_\n    !alert \"Age seems too high\"\n    !return 0  \n  _\n  !alert \"Valid age:\" age\n  !return 1\n_\n\n*25 @myAge\n!validateAge myAge @valid`,\n    utilities: `// Math utility functions\n~isEven-num_*num & % & 2 & == & 0 @check !return check_\n~isOdd-num_!isEven num @evencheck *evencheck & == & 0 @oddcheck !return oddcheck_\n~max-a-b_*a & > & b:if_!return a_!return b_\n\n*15 @testval\n!isOdd testval @odd\n!isEven testval @even\n!alert \"15 is odd:\" odd \"even:\" even\n\n*10 @x\n*20 @y\n!max x y @maximum\n!alert \"Max of\" x \"and\" y \"is\" maximum`\n};\nconst testCases = [\n    {\n        name: \"Simple variable assignment\",\n        input: \"*5 @x\",\n        expected: [\n            { type: token_1.TokenType.Asterisk, value: \"*\" },\n            { type: token_1.TokenType.Number, value: \"5\" },\n            { type: token_1.TokenType.At, value: \"@\" },\n            { type: token_1.TokenType.Identifier, value: \"x\" },\n            { type: token_1.TokenType.EOF, value: \"\" }\n        ]\n    },\n    {\n        name: \"String literal\",\n        input: '*\"Hello World\" @greeting',\n        expected: [\n            { type: token_1.TokenType.Asterisk, value: \"*\" },\n            { type: token_1.TokenType.String, value: \"Hello World\" },\n            { type: token_1.TokenType.At, value: \"@\" },\n            { type: token_1.TokenType.Identifier, value: \"greeting\" },\n            { type: token_1.TokenType.EOF, value: \"\" }\n        ]\n    },\n    {\n        name: \"Arithmetic expression\",\n        input: \"*x & + & y @sum\",\n        expected: [\n            { type: token_1.TokenType.Asterisk, value: \"*\" },\n            { type: token_1.TokenType.Identifier, value: \"x\" },\n            { type: token_1.TokenType.Ampersand, value: \"&\" },\n            { type: token_1.TokenType.Plus, value: \"+\" },\n            { type: token_1.TokenType.Ampersand, value: \"&\" },\n            { type: token_1.TokenType.Identifier, value: \"y\" },\n            { type: token_1.TokenType.At, value: \"@\" },\n            { type: token_1.TokenType.Identifier, value: \"sum\" },\n            { type: token_1.TokenType.EOF, value: \"\" }\n        ]\n    },\n    {\n        name: \"Function call\",\n        input: '!alert \"Boom!\"',\n        expected: [\n            { type: token_1.TokenType.Bang, value: \"!\" },\n            { type: token_1.TokenType.Alert, value: \"alert\" },\n            { type: token_1.TokenType.String, value: \"Boom!\" },\n            { type: token_1.TokenType.EOF, value: \"\" }\n        ]\n    },\n    {\n        name: \"Comparison operators\",\n        input: \"*x & == & 5\",\n        expected: [\n            { type: token_1.TokenType.Asterisk, value: \"*\" },\n            { type: token_1.TokenType.Identifier, value: \"x\" },\n            { type: token_1.TokenType.Ampersand, value: \"&\" },\n            { type: token_1.TokenType.EqualEqual, value: \"==\" },\n            { type: token_1.TokenType.Ampersand, value: \"&\" },\n            { type: token_1.TokenType.Number, value: \"5\" },\n            { type: token_1.TokenType.EOF, value: \"\" }\n        ]\n    },\n    {\n        name: \"Comments\",\n        input: \"// This is a comment\\n*5 @x\",\n        expected: [\n            { type: token_1.TokenType.Asterisk, value: \"*\" },\n            { type: token_1.TokenType.Number, value: \"5\" },\n            { type: token_1.TokenType.At, value: \"@\" },\n            { type: token_1.TokenType.Identifier, value: \"x\" },\n            { type: token_1.TokenType.EOF, value: \"\" }\n        ]\n    },\n    {\n        name: \"Complex expression with braces\",\n        input: \"~add-a-b_*a&+&b@result!return-result_\",\n        expected: [\n            { type: token_1.TokenType.Tilde, value: \"~\" },\n            { type: token_1.TokenType.Identifier, value: \"add\" },\n            { type: token_1.TokenType.Dash, value: \"-\" },\n            { type: token_1.TokenType.Identifier, value: \"a\" },\n            { type: token_1.TokenType.Dash, value: \"-\" },\n            { type: token_1.TokenType.Identifier, value: \"b\" },\n            { type: token_1.TokenType.Underscore, value: \"_\" },\n            { type: token_1.TokenType.Asterisk, value: \"*\" },\n            { type: token_1.TokenType.Identifier, value: \"a\" },\n            { type: token_1.TokenType.Ampersand, value: \"&\" },\n            { type: token_1.TokenType.Plus, value: \"+\" },\n            { type: token_1.TokenType.Ampersand, value: \"&\" },\n            { type: token_1.TokenType.Identifier, value: \"b\" },\n            { type: token_1.TokenType.At, value: \"@\" },\n            { type: token_1.TokenType.Identifier, value: \"result\" },\n            { type: token_1.TokenType.Bang, value: \"!\" },\n            { type: token_1.TokenType.Return, value: \"return\" },\n            { type: token_1.TokenType.Dash, value: \"-\" },\n            { type: token_1.TokenType.Identifier, value: \"result\" },\n            { type: token_1.TokenType.Underscore, value: \"_\" },\n            { type: token_1.TokenType.EOF, value: \"\" }\n        ]\n    }\n];\nclass WebREPL {\n    constructor() {\n        this.stats = {\n            tokensProcessed: 0,\n            examplesRun: 0,\n            errorsCaught: 0\n        };\n        this.codeInput = document.getElementById('code-input');\n        this.output = document.getElementById('output');\n        this.executionOutput = document.getElementById('execution-output');\n        this.errorSection = document.getElementById('error-section');\n        this.errorOutput = document.getElementById('error-output');\n        this.testResults = document.getElementById('test-results');\n        this.interpreter = new interpreter_1.Interpreter();\n        // Override the interpreter's alert function to show in the web UI\n        this.setupInterpreterAlert();\n        this.setupEventListeners();\n    }\n    setupInterpreterAlert() {\n        // Store the original console.log\n        const originalLog = console.log;\n        // Override console.log to capture interpreter output\n        console.log = (...args) => {\n            const message = args.join(' ');\n            this.addToExecutionOutput(message);\n            originalLog.apply(console, args);\n        };\n    }\n    addToExecutionOutput(message) {\n        const timestamp = new Date().toLocaleTimeString();\n        this.executionOutput.textContent += `[${timestamp}] ${message}\\n`;\n        this.executionOutput.scrollTop = this.executionOutput.scrollHeight;\n    }\n    setupEventListeners() {\n        // Tokenize button\n        const tokenizeBtn = document.getElementById('tokenize-btn');\n        tokenizeBtn?.addEventListener('click', () => this.tokenizeCode());\n        // Run button\n        const runBtn = document.getElementById('run-btn');\n        runBtn?.addEventListener('click', () => this.runCode());\n        // Clear button\n        const clearBtn = document.getElementById('clear-btn');\n        clearBtn?.addEventListener('click', () => this.clearAll());\n        // Example buttons\n        const exampleBtns = document.querySelectorAll('.example-btn-small');\n        exampleBtns.forEach(btn => {\n            btn.addEventListener('click', (e) => {\n                const target = e.target;\n                const exampleType = target.getAttribute('data-example');\n                this.loadExample(exampleType);\n            });\n        });\n        // Test button\n        const testBtn = document.getElementById('run-tests-btn');\n        testBtn?.addEventListener('click', () => this.runTests());\n        // Test examples button\n        const testExamplesBtn = document.getElementById('run-examples-btn');\n        testExamplesBtn?.addEventListener('click', () => this.testAllExamples());\n        // Enter key in textarea\n        this.codeInput.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {\n                e.preventDefault();\n                this.runCode();\n            }\n        });\n    }\n    tokenizeCode() {\n        const code = this.codeInput.value.trim();\n        if (!code) {\n            this.showError(\"Please enter some BombLang code to tokenize.\");\n            return;\n        }\n        try {\n            this.hideError();\n            const lexer = new lexer_1.Lexer(code);\n            const tokens = lexer.tokenize();\n            this.displayTokens(tokens);\n            this.stats.tokensProcessed += tokens.length;\n            this.updateStats();\n        }\n        catch (error) {\n            this.stats.errorsCaught++;\n            this.updateStats();\n            this.showError(error instanceof Error ? error.message : \"An unknown error occurred.\");\n        }\n    }\n    runCode() {\n        const code = this.codeInput.value.trim();\n        if (!code) {\n            this.showError(\"Please enter some BombLang code to run.\");\n            return;\n        }\n        try {\n            this.hideError();\n            this.executionOutput.textContent = \"\"; // Clear previous output\n            this.addToExecutionOutput(\"🚀 Starting execution...\");\n            const lexer = new lexer_1.Lexer(code);\n            const tokens = lexer.tokenize();\n            const parser = new parser_1.Parser(tokens);\n            const ast = parser.parse();\n            this.interpreter.interpret(ast);\n            this.addToExecutionOutput(\"✅ Execution completed successfully!\");\n            this.stats.tokensProcessed += tokens.length;\n            this.stats.examplesRun++;\n            this.updateStats();\n            // Also show tokens for debugging\n            this.displayTokens(tokens);\n        }\n        catch (error) {\n            this.stats.errorsCaught++;\n            this.updateStats();\n            const errorMsg = error instanceof Error ? error.message : \"An unknown error occurred.\";\n            this.addToExecutionOutput(`💥 Explosion: ${errorMsg}`);\n            this.showError(errorMsg);\n        }\n    }\n    displayTokens(tokens) {\n        this.output.innerHTML = '';\n        if (tokens.length === 1 && tokens[0].type === token_1.TokenType.EOF) {\n            this.output.innerHTML = '<div class=\"token\">No tokens found (empty input)</div>';\n            return;\n        }\n        tokens.forEach((token, index) => {\n            if (token.type !== token_1.TokenType.EOF) {\n                const tokenElement = document.createElement('div');\n                tokenElement.className = 'token';\n                tokenElement.innerHTML = `\n                    <span class=\"token-type\">${token.type}</span>: \n                    <span class=\"token-value\">'${this.escapeHtml(token.value)}'</span>\n                    <span class=\"token-position\">(line ${token.line}, col ${token.column})</span>\n                `;\n                this.output.appendChild(tokenElement);\n            }\n        });\n        // Add a summary\n        const nonEofTokens = tokens.filter(t => t.type !== token_1.TokenType.EOF);\n        const summary = document.createElement('div');\n        summary.style.marginTop = '15px';\n        summary.style.padding = '10px';\n        summary.style.background = '#e7f3ff';\n        summary.style.borderRadius = '6px';\n        summary.style.borderLeft = '4px solid #007bff';\n        summary.innerHTML = `<strong>Summary:</strong> Found ${nonEofTokens.length} tokens`;\n        this.output.appendChild(summary);\n    }\n    showError(message) {\n        this.errorOutput.textContent = message;\n        this.errorSection.style.display = 'block';\n    }\n    hideError() {\n        this.errorSection.style.display = 'none';\n    }\n    clearAll() {\n        this.codeInput.value = '';\n        this.output.innerHTML = '';\n        this.executionOutput.textContent = 'Ready for explosive code! 💣';\n        this.hideError();\n        this.codeInput.focus();\n    }\n    loadExample(exampleType) {\n        this.codeInput.value = examples[exampleType];\n        this.hideError();\n        this.output.innerHTML = '';\n        this.executionOutput.textContent = `Loaded ${exampleType} example - ready to explode! 💥`;\n        this.codeInput.focus();\n        this.stats.examplesRun++;\n        this.updateStats();\n    }\n    testAllExamples() {\n        this.testResults.innerHTML = '<div>🧪 Testing all examples...</div>';\n        let passed = 0;\n        let failed = 0;\n        const results = [];\n        Object.entries(examples).forEach(([name, code]) => {\n            try {\n                const lexer = new lexer_1.Lexer(code);\n                const tokens = lexer.tokenize();\n                const parser = new parser_1.Parser(tokens);\n                const ast = parser.parse();\n                // Create a temporary interpreter for testing\n                const testInterpreter = new interpreter_1.Interpreter();\n                testInterpreter.interpret(ast);\n                passed++;\n                results.push(`<div class=\"test-pass\">✅ ${name} - Example runs successfully</div>`);\n            }\n            catch (error) {\n                failed++;\n                const errorMsg = error instanceof Error ? error.message : \"Unknown error\";\n                results.push(`<div class=\"test-fail\">❌ ${name}<br>&nbsp;&nbsp;&nbsp;&nbsp;Error: ${errorMsg}</div>`);\n            }\n        });\n        // Display results\n        const summaryClass = failed === 0 ? 'success' : 'failure';\n        const summaryText = `Example tests completed: ${passed} passed, ${failed} failed`;\n        this.testResults.innerHTML = `\n            <div class=\"test-summary ${summaryClass}\">${summaryText}</div>\n            ${results.join('')}\n        `;\n    }\n    runTests() {\n        this.testResults.innerHTML = '<div>🧪 Running lexer tests...</div>';\n        let passed = 0;\n        let failed = 0;\n        const results = [];\n        testCases.forEach((testCase, index) => {\n            try {\n                const lexer = new lexer_1.Lexer(testCase.input);\n                const tokens = lexer.tokenize();\n                // Compare tokens\n                let testPassed = true;\n                let errorMessage = '';\n                if (tokens.length !== testCase.expected.length) {\n                    testPassed = false;\n                    errorMessage = `Expected ${testCase.expected.length} tokens, got ${tokens.length}`;\n                }\n                else {\n                    for (let i = 0; i < tokens.length; i++) {\n                        if (tokens[i].type !== testCase.expected[i].type ||\n                            tokens[i].value !== testCase.expected[i].value) {\n                            testPassed = false;\n                            errorMessage = `Token ${i}: expected ${testCase.expected[i].type}:'${testCase.expected[i].value}', got ${tokens[i].type}:'${tokens[i].value}'`;\n                            break;\n                        }\n                    }\n                }\n                if (testPassed) {\n                    passed++;\n                    results.push(`<div class=\"test-pass\">✅ ${testCase.name}</div>`);\n                }\n                else {\n                    failed++;\n                    results.push(`<div class=\"test-fail\">❌ ${testCase.name}<br>&nbsp;&nbsp;&nbsp;&nbsp;${errorMessage}</div>`);\n                }\n            }\n            catch (error) {\n                failed++;\n                const errorMsg = error instanceof Error ? error.message : \"Unknown error\";\n                results.push(`<div class=\"test-fail\">❌ ${testCase.name}<br>&nbsp;&nbsp;&nbsp;&nbsp;Error: ${errorMsg}</div>`);\n            }\n        });\n        // Display results\n        const summaryClass = failed === 0 ? 'success' : 'failure';\n        const summaryText = `Lexer tests completed: ${passed} passed, ${failed} failed`;\n        this.testResults.innerHTML = `\n            <div class=\"test-summary ${summaryClass}\">${summaryText}</div>\n            ${results.join('')}\n        `;\n    }\n    updateStats() {\n        const tokensEl = document.getElementById('tokens-processed');\n        const examplesEl = document.getElementById('examples-run');\n        const errorsEl = document.getElementById('errors-caught');\n        if (tokensEl)\n            tokensEl.textContent = this.stats.tokensProcessed.toString();\n        if (examplesEl)\n            examplesEl.textContent = this.stats.examplesRun.toString();\n        if (errorsEl)\n            errorsEl.textContent = this.stats.errorsCaught.toString();\n    }\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n}\n// Initialize the REPL when the page loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new WebREPL();\n});\n"],"names":[],"sourceRoot":""}